# Day 2

## Continuing JavaScript recap

### From yesterday
```
(function moreMath() {
	console.log('moremath!!');
})();

var myMathFunction = function(numberOne, numberTwo, lastNumber) {	
	return numberOne * numberTwo NaN + 'four' + lastNumber;
}	//	Assigns anonymous function to var myMathFunction, which can be called later

var cat = myMathFunction();	//	Assigns function to var cat

//	var result = doMaths();
// 	if(result > 0) {
//		console.log("Correct!");
//	}
```

### Hoisting

Variable declarations are hoisted to the top, setting aside memory for the program to be used later. Assignments are executed in order.

Function declarations are hoisted to the top as well, but are not executed until called.

Hoisting also occurs within functions with local variables.

#### Example
##### Before:

```
var i;

function moreMath() {
	console.log('moremath!!');
};

console.log('line 22');

var myName = 'Kris';
if(myName == 'Kris') {
	myCat = 'Spot';
}
var myCat = 'Luna';

(function anotherCar() {
	var x = 10;
	console.log('function ran!');
})();

return;

var i;
```

##### After:
```
var i = undefined;
var myName = undefined;
var myCat = undefined;

function moreMath() {
	console.log('moremath!!');
};

var myName = 'Kris';	//	From undefined
var myCat = 'Luna';		// 	From undefined

return;					//	Ends execution

var i;
```

### Scoping
The only way to get a new scope (other than global) is to use a function. For example, declared variables within `for` or `while` loops are global, __NOT__ local. Variables declared within these loops are hoisted along with other global variables.